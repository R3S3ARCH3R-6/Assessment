package eg1;

public class MobileObjectCasting {

	public static void main(String[] args) {
		/*
		 * Object casting 
		 * 1) It's possible only and only b/w the parent and the child relationship only
		 *  - we cannot convert one obj into just any obj
		 * 2) If there is no relationship of if the child object is not created and you 
		 *  try to convert your parent object to Child class, it will throw unchecked ClassCastException
		 *   -(happens when we have no __ )
		 * Relationship also means it cannot be siblings
		 * - class having mult children (can only convert obj b/w parent and child, not b/w the children)
		 * - siblings cannot be converted into each other
		 * we can also convert b/w a grandparent and grandchild
		 * 3) Conversion b/w siblings is not possible
		 * 
		 * Types of Casting
		 * 1) Implicit Casting (Done by compiler) - where child class obj can be assigned to parent class implicitly,
		 *   but remember, this doesn't mean the parent will be able to access child method until any method is overriden from parent
		 * 2) Explicit Casting (done by developer) - explicitly converting the reference of a parent to the child 
		 * 
		 * */

		//MobileV3 v3 = new MobileV1(); <--not casting (this is an error)	
			//this causes a ClassCastException
			//new MobileV1();	//has methods: calling() & all methods of Object class
			//this causes errors b/c you are preventing a MobileV3 element from accessing the MobileV2 elements it should have access to

		//MobileV1 v1 = new MobileV3(); //MobileV3, MobileV2, MobileV1, Object <--hierarchy of classes
			//we can still access the MobileV1 methods this way because MobileV3 inherits MobileV1 methods it can use
			//it cannot use MobileV2 or MobileV3 methods
		
		MobileV1 v1 = new MobileV3();
		System.out.println(v1.getClass());
		v1.calling();
	}

}
